// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2022 Dell Inc, or its subsidiaries.
// {C} Copyright 2022 Pensando Systems Inc. All rights reserved

syntax = "proto3";
package opi_api.storage.v1;

option java_package = "opi_api.storage.v1";
option java_multiple_files = true;
option java_outer_classname = "FrontendNvmePcieProto";

option go_package = "github.com/opiproject/opi-api/storage/v1alpha1/gen/go";
import "opicommon.proto";
import "object_key.proto";
import "uuid.proto";

import "google/api/client.proto";
import "google/api/resource.proto";
import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/field_mask.proto";

// Front End (host-facing) APIs. Both PCIe and Fabrics.
service FrontendNvmeService {
    rpc CreateNvmeFrontendSubsystem (CreateNvmeFrontendSubsystemRequest) returns (NvmeFrontendSubsystem) {
        option (google.api.http) = {
            post: "/v1/{parent=subsystems}"
            body: "nvme_fe_subsystem"
        };
        option (google.api.method_signature) = "parent,nvme_fe_subsystem,nvme_fe_subsystem_id";
    }
    rpc DeleteNvmeFrontendSubsystem (DeleteNvmeFrontendSubsystemRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            delete: "/v1/{name=subsystems}/{subsystem}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc UpdateNvmeFrontendSubsystem (UpdateNvmeFrontendSubsystemRequest) returns (NvmeFrontendSubsystem) {
        option (google.api.http) = {
            patch: "/v1/{nvme_fe_subsystem.name=subsystems}"
            body: "nvme_fe_subsystem"
        };
        option (google.api.method_signature) = "nvme_fe_subsystem,update_mask";
    }
    rpc ListNvmeFrontendSubsystems   (ListNvmeFrontendSubsystemsRequest)   returns (ListNvmeFrontendSubsystemsResponse)   {
        option (google.api.http) = {
            get: "/v1/{parent=subsystems}"
        };
        option (google.api.method_signature) = "parent";
    }
    rpc GetNvmeFrontendSubsystem    (GetNvmeFrontendSubsystemRequest)    returns (NvmeFrontendSubsystem)    {
        option (google.api.http) = {
            get: "/v1/{name=subsystems}/{subsystem}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc NvmeFrontendSubsystemStats  (NvmeFrontendSubsystemStatsRequest)  returns (NvmeFrontendSubsystemStatsResponse)  {}

    rpc CreateNvmeFrontendController (CreateNvmeFrontendControllerRequest) returns (NvmeFrontendController) {
        option (google.api.http) = {
            post: "/v1/{parent=subsystems}"
            body: "nvme_fe_controller"
        };
        option (google.api.method_signature) = "parent,nvme_fe_controller,nvme_fe_controller_id";
    }
    rpc DeleteNvmeFrontendController (DeleteNvmeFrontendControllerRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            delete: "/v1/{name=controllers}/{controller}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc UpdateNvmeFrontendController (UpdateNvmeFrontendControllerRequest) returns (NvmeFrontendController) {
        option (google.api.http) = {
            patch: "/v1/{nvme_fe_controller.name=subsystems}"
            body: "nvme_fe_controller"
        };
        option (google.api.method_signature) = "nvme_fe_controller,update_mask";
    }
    rpc ListNvmeFrontendControllers   (ListNvmeFrontendControllersRequest)   returns (ListNvmeFrontendControllersResponse)   {
        option (google.api.http) = {
            get: "/v1/{parent=subsystems}"
        };
        option (google.api.method_signature) = "parent";
    }
    rpc GetNvmeFrontendController    (GetNvmeFrontendControllerRequest)    returns (NvmeFrontendController)    {
        option (google.api.http) = {
            get: "/v1/{name=subsystems}/{controller}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc NvmeFrontendControllerStats  (NvmeFrontendControllerStatsRequest)  returns (NvmeFrontendControllerStatsResponse)  {}

    rpc CreateNvmeFrontendEndpoint (CreateNvmeFrontendEndpointRequest) returns (NvmeFrontendEndpoint) {
        option (google.api.http) = {
            post: "/v1/{parent=subsystems}"
            body: "nvme_fe_endpoint"
        };
        option (google.api.method_signature) = "parent,nvme_fe_endpoint,nvme_fe_endpoint_id";
    }
    rpc DeleteNvmeFrontendEndpoint (DeleteNvmeFrontendEndpointRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            delete: "/v1/{name=endpoints}/{endpoint}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc UpdateNvmeFrontendEndpoint (UpdateNvmeFrontendEndpointRequest) returns (NvmeFrontendEndpoint) {
        option (google.api.http) = {
            patch: "/v1/{nvme_fe_endpoint.name=subsystems}"
            body: "nvme_fe_endpoint"
        };
        option (google.api.method_signature) = "nvme_fe_endpoint,update_mask";
    }
    rpc ListNvmeFrontendEndpoint   (ListNvmeFrontendEndpointRequest)   returns (ListNvmeFrontendEndpointResponse)   {
        option (google.api.http) = {
            get: "/v1/{parent=subsystems}"
        };
        option (google.api.method_signature) = "parent";
    }
    rpc GetNvmeFrontendEndpoint    (GetNvmeFrontendEndpointRequest)    returns (NvmeFrontendEndpoint)    {
        option (google.api.http) = {
            get: "/v1/{name=subsystems}/{endpoint}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc NvmeFrontendEndpointStats  (NvmeFrontendEndpointStatsRequest)  returns (NvmeFrontendEndpointStatsResponse)  {}

    rpc CreateNvmeFrontendNamespace (CreateNvmeFrontendNamespaceRequest) returns (NvmeFrontendNamespace) {
        option (google.api.http) = {
            post: "/v1/{parent=subsystems}"
            body: "nvme_fe_namespace"
        };
        option (google.api.method_signature) = "parent,nvme_fe_namespace,nvme_fe_namespace_id";
    }
    rpc DeleteNvmeFrontendNamespace (DeleteNvmeFrontendNamespaceRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            delete: "/v1/{name=namespaces}/{namespace}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc UpdateNvmeFrontendNamespace (UpdateNvmeFrontendNamespaceRequest) returns (NvmeFrontendNamespace) {
        option (google.api.http) = {
            patch: "/v1/{nvme_fe_namespace.name=subsystems}"
            body: "nvme_fe_namespace"
        };
        option (google.api.method_signature) = "nvme_fe_namespace,update_mask";
    }
    rpc ListNvmeFrontendNamespaces   (ListNvmeFrontendNamespacesRequest)   returns (ListNvmeFrontendNamespacesResponse)   {
        option (google.api.http) = {
            get: "/v1/{parent=subsystems}"
        };
        option (google.api.method_signature) = "parent";
    }
    rpc GetNvmeFrontendNamespace    (GetNvmeFrontendNamespaceRequest)    returns (NvmeFrontendNamespace)    {
        option (google.api.http) = {
            get: "/v1/{name=subsystems}/{namespace}"
        };
        option (google.api.method_signature) = "name";
    }
    rpc NvmeFrontendNamespaceStats  (NvmeFrontendNamespaceStatsRequest)  returns (NvmeFrontendNamespaceStatsResponse)  {}
}

message NvmeFrontendSubsystem {
  NvmeFrontendSubsystemSpec   spec   = 1;
  NvmeFrontendSubsystemStatus status = 2;
}

message NvmeFrontendSubsystemSpec {
    // object's unique identifier
    common.v1.ObjectKey id = 1;

    // NvmeFrontend subsystem NQN to which the controller belongs
    // Refer to the NQN format in the NvmeFrontend base specifications, must not
    // exceed 'NSV_NVME_SUBSYSTEM_NQN_LEN' bytes
    string nqn = 2;

    // serial number must not exceed 'NSV_CTRLR_SERIAL_NO_LEN' bytes
    string serial_number = 3;

    // model number, must not exceed 'NSV_CTRLR_MODEL_NO_LEN' bytes
    string model_number = 4;

    // maximum namespaces within a subsystem
    int64 max_namespaces = 5;
}

message NvmeFrontendSubsystemStatus {
    // firmware revision, must not exceed 'NSV_CTRLR_FW_REV_LEN'
    string firmware_revision  = 1;

    // FRU identfier, 16bytes opaque identity for the type of unit
    bytes fru_guid = 2;
}

message NvmeFrontendController {
  NvmeFrontendControllerSpec   spec   = 1;
  NvmeFrontendControllerStatus status = 2;
}

message NvmeFrontendControllerSpec {
    // object's unique identifier
    common.v1.ObjectKey id = 1;

    // subsystem controller id range: 0 to 65535.
    // must not be reused under the same subsystem
    int32 nvme_controller_id  = 2;

    // subsystem information
    common.v1.ObjectKey subsystem_id = 3;

    // xPU's PCI ID for the controller
    PciEndpoint pcie_id = 4;

    // maximum number of host submission queues allowed.
    // If not set, the xPU will provide a default.
    int32 max_nsq = 5;

    // maximum number of host completion queues allowed.
    // If not set, the xPU will provide a default.
    int32 max_ncq = 6;
  
    // maximum number of submission queue entries per submission queue, as a power of 2.
    // default value as per spec is 6
    int32 sqes = 7;

    // maximum number of completion queue entries per completion queue, as a power of 2.
    // default value as per spec is 4
    int32 cqes = 8;

    // maximum Number of namespaces that will be provisioned under
    // the controller.
    int32 max_namespaces = 9;
}

message NvmeFrontendControllerStatus {
    // Device is in use by host nvme driver
    bool   active = 1;
}

message NvmeFrontendEndpoint {
  NvmeFrontendEndpointSpec   spec   = 1;
  NvmeFrontendEndpointStatus status = 2;
}

message NvmeFrontendEndpointSpec {
    // object's unique identifier
    common.v1.ObjectKey id = 1;

    FabricEndpoint fabric_id = 4;

    // TLS?

    // Access Control?
}

message NvmeFrontendEndpointStatus {
    // Endpoint is ready to accept connections
    bool   active = 1;
}

message NvmeFrontendNamespace {
  NvmeFrontendNamespaceSpec   spec   = 1;
  NvmeFrontendNamespaceStatus status = 2;
}

message NvmeFrontendNamespaceSpec {
    // namespace's unique key
    common.v1.ObjectKey id = 1;

    // subsystem for this namespace
    common.v1.ObjectKey subsystem_id = 2;

    // NSID present to the host by the NVMe PCIe controller.
    // If not provided, then the controller will assign an unused NSID
    // within the max namespace range - auto assigned nsid may not work
    // for live migration
    int32 host_nsid = 4;

    // Globally unique identifier for the namespace
    string nguid = 7;

    // 64bit Extended unique identifier for the namespace
    // mandatory if guid is not specified
    int64 eui64 = 8;

    // Globally unique identifier for the namespace
    common.v1.Uuid uuid = 9;

    // The back/middle-end volume to back this namespace.
    common.v1.ObjectKey volume_id = 10;
}

message NvmeFrontendNamespaceStatus {
    // config state of the namespace object, (enabled, disable, deleting)
    NvmeFrontendNamespacePciState      pci_state       = 1;

    // Operational state of the namespace object, (connected, disconnected)
    NvmeFrontendNamespacePciOperState  pci_oper_state   = 2;
}

message CreateNvmeFrontendSubsystemRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendSubsystem"
    ];
    NvmeFrontendSubsystem nvme_fe_subsystem = 2 [(google.api.field_behavior) = REQUIRED];
    string nvme_fe_subsystem_id = 3;
}

message DeleteNvmeFrontendSubsystemRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendSubsystem"
    ];
    // If set to true, and the resource is not found, the request will succeed
    // but no action will be taken on the server
    bool allow_missing = 2;
}

message UpdateNvmeFrontendSubsystemRequest {
    NvmeFrontendSubsystem nvme_fe_subsystem = 1;
    // The list of fields to update.
    google.protobuf.FieldMask update_mask = 2;
}

message ListNvmeFrontendSubsystemsRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendSubsystem"
    ];
    int32 page_size = 2;
    string page_token = 3;
}

message ListNvmeFrontendSubsystemsResponse {
    repeated NvmeFrontendSubsystem nvme_fe_subsystems = 1;
    string next_page_token = 2;
}

message GetNvmeFrontendSubsystemRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendSubsystem"
    ];
}

message NvmeFrontendSubsystemStatsRequest {
    common.v1.ObjectKey subsystem_id = 1;
}

message NvmeFrontendSubsystemStatsResponse {
    VolumeStats stats = 1;
}

message CreateNvmeFrontendControllerRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendController"
    ];
    NvmeFrontendController nvme_fe_controller = 2 [(google.api.field_behavior) = REQUIRED];
    string nvme_fe_controller_id = 3;
}

message DeleteNvmeFrontendControllerRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendController"
    ];
    // If set to true, and the resource is not found, the request will succeed
    // but no action will be taken on the server
    bool allow_missing = 2;
}

message UpdateNvmeFrontendControllerRequest {
    NvmeFrontendController nvme_fe_controller = 1;
    // The list of fields to update.
    google.protobuf.FieldMask update_mask = 2;
}

message ListNvmeFrontendControllersRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendController"
    ];
    int32 page_size = 2;
    string page_token = 3;
}

message ListNvmeFrontendControllersResponse {
    repeated NvmeFrontendController nvme_fe_controllers = 1;
    string next_page_token = 2;
}

message GetNvmeFrontendControllerRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendController"
    ];
}

message NvmeFrontendControllerStatsRequest {
    common.v1.ObjectKey id = 1;
}

message NvmeFrontendControllerStatsResponse {
    common.v1.ObjectKey id = 1;
    VolumeStats stats = 2;
}

message CreateNvmeFrontendEndpointRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendEndpoint"
    ];
    NvmeFrontendEndpoint nvme_fe_endpoint = 2 [(google.api.field_behavior) = REQUIRED];
    string nvme_fe_controller_id = 3;
}

message DeleteNvmeFrontendEndpointRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendEndpoint"
    ];
    // If set to true, and the resource is not found, the request will succeed
    // but no action will be taken on the server
    bool allow_missing = 2;
}

message UpdateNvmeFrontendEndpointRequest {
    NvmeFrontendEndpoint nvme_fe_endpoint = 1;
    // The list of fields to update.
    google.protobuf.FieldMask update_mask = 2;
}

message ListNvmeFrontendEndpointsRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendEndpoint"
    ];
    int32 page_size = 2;
    string page_token = 3;
}

message ListNvmeFrontendEndpointsResponse {
    repeated NvmeFrontendEndpoint nvme_fe_endpoints = 1;
    string next_page_token = 2;
}

message GetNvmeFrontendEndpointRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendEndpoint"
    ];
}

message NvmeFrontendEndpointStatsRequest {
    common.v1.ObjectKey id = 1;
}

message NvmeFrontendEndpointStatsResponse {
    common.v1.ObjectKey id = 1;
}

message CreateNvmeFrontendNamespaceRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendNamespace"
    ];
    NvmeFrontendNamespace nvme_fe_namespace = 2 [(google.api.field_behavior) = REQUIRED];
    string nvme_fe_namespace_id = 3;
}

message DeleteNvmeFrontendNamespaceRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendNamespace"
    ];
    // If set to true, and the resource is not found, the request will succeed
    // but no action will be taken on the server
    bool allow_missing = 2;
}

message UpdateNvmeFrontendNamespaceRequest {
    NvmeFrontendNamespace nvme_fe_namespace = 1;
    // The list of fields to update.
    google.protobuf.FieldMask update_mask = 2;
}

message ListNvmeFrontendNamespacesRequest {
    string parent = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendNamespace"
    ];
    int32 page_size = 2;
    string page_token = 3;
}

message ListNvmeFrontendNamespacesResponse {
    repeated NvmeFrontendNamespace nvme_fe_namespaces = 1;
    string next_page_token = 2;
}

message GetNvmeFrontendNamespaceRequest {
    string name = 1 [
        (google.api.field_behavior) = REQUIRED,
        (google.api.resource_reference).type = "opi_api.storage.v1/NvmeFrontendNamespace"
    ];
}

message NvmeFrontendNamespaceStatsRequest {
    common.v1.ObjectKey namespace_id = 1;
}

message NvmeFrontendNamespaceStatsResponse {
    common.v1.ObjectKey id = 1;
    VolumeStats stats = 2;
}

// Namespace  Administrative States
enum NvmeFrontendNamespacePciState {
    // unspecified
    NV_ME_NAMESPACE_PCI_STATE_UNSPECIFIED = 0;
    // namespace disabled state
    NVME_NAMESPACE_PCI_STATE_DISABLED    = 1;
    // namespace enabled state
    NVME_NAMESPACE_PCI_STATE_ENABLED     = 2;
    // namespace being deleted
    NVME_NAMESPACE_PCI_STATE_DELETING    = 3;
}

// Namespace PCIe operational states
enum NvmeFrontendNamespacePciOperState {
    // unspecified
    NV_ME_NAMESPACE_PCI_OPER_STATE_UNSPECIFIED = 0;
    // namespace is online and operational
    NVME_NAMESPACE_PCI_OPER_STATE_ONLINE = 1;
    // namespace is offline
    NVME_NAMESPACE_PCI_OPER_STATE_OFFLINE= 2;
}

